<!DOCTYPE html>
<html>
  <head>
    <title>a96</title>
    <link rel="shortcut icon" href="#" />
    <link rel="stylesheet" type="text/css" href="/common/css/commonStyles.css" />
    <link rel="stylesheet" type="text/css" href="/common/css/msStyles.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/3.12.2/js-yaml.js"></script>
    <script src="https://www.w3schools.com/lib/w3.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

    <script src="/common/js/helpers.js"></script>
    <script src="/common/js/panzoom.js"></script>
    <script src="/common/js/MS.js"></script>
    <script src="/common/js/BoardFactory.js"></script>
    <script src="/common/js/CardFactory.js"></script>
    <!-- <script src="/common/js/MTree.js"></script>
    <script src="/common/js/MParser.js"></script>
    <script src="/common/js/MScanner.js"></script> -->
  </head>
  <body>
    <!-- #region HTML -->
    <div id="mainDiv" class="grid-hidefirst">
      <div id="statusDiv" class="div">status</div>
      <div id="selDiv" class="div hidden">
        <svg id="selSvg" width="60" height="760"><g id="selG"></g></svg>
      </div>
      <div id="rootDiv" class="div" style="background-color:rgba(86, 182, 222);">
        <svg width="100%" height="100%" style="box-sizing:border-box;">
          <g id="boardG" viewBox="0 0 3400 2200">
            <image id="imgMap" width="3400" height="2200" href="/common/assets/TTmap.jpg" />
          </g>
        </svg>
      </div>
      <div id="logDiv" class="div" style="overflow-y:scroll">Messages</div>
      <div id="buttonDiv" class="div">
        <button id="bNextPlayer" class="hidden" onclick="onClickNextPlayer()">next player</button>
        <button id="bSave" onclick="saveGameState()">save</button>
        <button id="bPass" class="hidden" onclick="onClickPass()">pass</button>
      </div>
      <div id="cardDisplay" class="div" style="height:200px">
        <svg width="100%" height="100%" style="box-sizing:border-box;">
          <g id="cardsG"></g>
        </svg>
      </div>
      <div id="chatWindow" class="div">
        <button id="bSkipAction" onclick="skipAction()">skip</button>
      </div>
    </div>
    <!-- #endregion HTML -->

    <!-- #region functions -->
    <script>
      function send(url) {
        url = backendServerUrl + url;
        msgCounter += 1;
        console.log(msgCounter, "request sent: ", url);
        w3.http(url, function() {
          if (this.readyState == 4 && this.status == 200) {
            processData(this.responseText);
          }
        });
      }
      function skipAction() {
        let tuple = choiceTuples[0];
        let url = "action/" + G.faction + "/" + tuple.join("+");
        //choiceTuples = [];
        //console.log("skipAction choiceTuples:", choiceTuples);
        closeSelection();
        send(url);
      }
      function saveGameState() {
        //console.log(G);
        //console.log("_____________");
        //settings = {any_kind_of_object: true};
        json_str = JSON.stringify(G);
        saveFile("yourfilename.json", "data:application/json", new Blob([json_str], {type: ""}));
      }
      function onClickNextPlayer() {
        hide(bNextPlayer);
        cardFactory.clearCards();
        //TODO: hide board objects?
        G.previousFaction = G.faction;
        G.faction = nextFaction;
        send("status/" + G.faction);
        //send("reset/" + G.faction); //TODO: try this next!!!
      }
      function onClickPass() {
        // macht eh dasselbe wie onClickNextPlayer
        hide(bNextPlayer);
        cardFactory.clearCards();
        //TODO: hide board objects?
        G.previousFaction = G.faction;
        G.faction = nextFaction;
        send("status/" + G.faction);
      }
      function processReset(data) {
        let faction = G.previousFaction;
        let g = G[faction];
        //console.log("faction", faction);
        for (k in data) {
          let sk = k.toString();
          g[sk] = data[k];
        }
        //console.log("G[faction]", g);
        updateUI();
        send("status/" + faction);
      }
      function processData(str) {
        let data = JSON.parse(str);
        console.log(data);
        if ("invest_55" in data) {
          //console.log("THESE ARE RESET DATA!!!",data);
          processReset(data);
          return;
        }
        if (data === undefined) {
          //console.log("!!!", str, "!!!");
        } else {
          let faction = G.faction;
          let g = G[faction];
          if ("log" in data) {
            let msg = JSON.stringify(data.log);
            msg = msg.replace(/(?:\r\n|\r|\n)/g, "<br>");
            msg = msg.replace("\\n", "<br>");
            msg = msg.replace(/\\n/g, "<br>");
            msg = msg.replace(/"/g, "");
            if (msg.trim().length > 0) {
              let d=document.getElementById("logDiv");
              let para = document.createElement("p");
              para.innerHTML = msg;
              d.appendChild(para);
              para.scrollIntoView();
              G.log.push(msg);
            }
          }
          //created
          for (id in data.created) {
            let sid = id.toString();
            g[sid] = data.created[id]; //overwride object of have already
          }
          //updated
          for (id in data.updated) {
            let sid = id.toString();
            //not sure if have to do this really, since possibly no need
            // actually, the object might NOT exist,
            // therefore, just create it if it does not exist!!!

            if (!(sid in g)) {
              //console.log("NON EXISTING:", sid);
              g[sid] = data.updated[id];
            } else {
              let o = g[sid]; //this object should exist since it is being updated!
              //each property of this object should be changed as in data.updated
              let orig = data.updated[id];
              for (prop in orig) {
                o[prop] = orig[prop];
              }
            }
          }
          //removed

          for (id in data.removed) {
            let sid = id.toString();
            //console.log(id, "is in removed!!!!!!!!!!!!!!");
            break;
            //not sure if should do anything!
            // if (id in g) {
            //   delete g[id];
            // }
          }

          //hier mach sowas wie Presenter.updateUI();
          updateUI();

          //either actions or waiting_for:
          //console.log("*** actions starts ***");
          //console.log(data.actions);

          // to save action data in case of bug:
          //json_str = JSON.stringify(data.actions);
          //saveFile("_a"+fileCounter+".json", "data:application/json", new Blob([json_str], {type: ""}));
          //fileCounter += 1;

          if ("actions" in data) {
            choiceTuples = expand(data.actions);
            //prj(choiceTuples); // //console.log

            if (skipActions > 0) {
              skipActions -= 1;
              let url = "action/" + G.faction + "/" + choiceTuples[0].join("+");
              choiceTuples = [];
              send(url);
            } else {
              //find all individual ids in choiceTuples
              //console.log("in processData:actions: vor highlithObjects");
              //console.log(choiceTuples);
              let uiGroups = highlightObjects(choiceTuples, choiceTuples, []);
              //console.log("ui groups", uiGroups, uiGroups.choice);
              openSelectionIfPopulated(uiGroups.choice);
              show(bSkipAction);

              // //old code
              // currentChoiceTuples = choiceTuples.slice();
              // //console.log("choices", choiceTuples);
              // currentChoicesByType = computeChoicesByType(currentChoiceTuples);

              // choiceUIs = getObjects(currentChoicesByType);
              // //console.log("_____________selection:");
              // //console.log(choiceUIs.map(x => x.id));
            }
          } else {
            //console.log(data.waiting_for, "*** will change turn!!! ***");
            //console.log(data);
            hideCommands();
            hideSelectionPanel();
            nextFaction = data.waiting_for.set[0];

            if (skipActions > 0) {
              onClickNextPlayer();
            } else {
              show(bNextPlayer);
            }
          }
        }
      }
      function onSelected(ev) {
        let id = evToId(ev);

        //check if this object was selected, if so, unselect!
        if (selids.includes(id)) {
          selids = without(selids, id);
          //console.log(id, " UNselected!!!", selids.toString());

          //from all choiceTuples,find those that contains all elements in selids
          let newChoiceTuples = getListsContainingAll(choiceTuples, selids);
          //console.log("new choice tuples:");
          //prj(newChoiceTuples);
          highlightObjects(choiceTuples, newChoiceTuples, selids);
        } else {
          //console.log(id, " selected!");
          selids.push(id);

          //check if complete choice is selected
          // let tuple = containsSet(choiceTuples, selids);
          let newChoiceTuples = getListsContainingAll(choiceTuples, selids);

          if (newChoiceTuples.length == 1) {
            let tuple = newChoiceTuples[0];
            //console.log("onSelected: found tuple");
            closeSelection();
            let url = "action/" + G.faction + "/" + tuple.join("+");
            send(url);
          } else {
            //newChoiceTuples = getListsContainingAll(choiceTuples, selids);
            //console.log("new choice tuples:");
            //prj(newChoiceTuples);
            highlightObjects(choiceTuples, newChoiceTuples, selids);
          }
        }
      }
    </script>
    <!-- #endregion functions -->

    <!-- #region FRONT END functions -->
    <script>
      function getInfluenceId(nation) {
        return "inf_" + nation;
      }
      function setInfluence(nation, faction, level) {
        let id = getInfluenceId(nation);
        if (!(id in uis)) {
          let ms = boardFactory.createInfluence(id, nation, faction, level); //also places!
          uis[id] = ms;
        } else {
          boardFactory.updateInfluence(id, nation, faction, level);
        }
      }
      function updateUI() {
        var currentFaction = G.faction;
        var currentView = G[currentFaction];

        for (id in currentView) {
          let go = currentView[id];
          let ttext = JSON.stringify(go);

          if (!(id in uis)) {
            //create object
            switch (go.obj_type) {
              case "tile":
                //console.log("create region", id);
                uis[id] = boardFactory.createTile(id, ttext);
                break;
              case "unit":
                //console.log("create unit", id);
                let faction = currentFaction;

                if (isUnitOfFaction(go, currentFaction)) {
                  uis[id] = boardFactory.createUnit(id, currentFaction, go, ttext);
                  boardFactory.updateCv(uis[id], go.cv);
                } else {
                  faction = go.visible.set[0];
                }
                //console.log("unit", uis[id],'id:::',id);
                //create or update hidden unit
                let idHidden = getHiddenId(faction, go.tile);
                if (!(idHidden in uis)) {
                  uis[idHidden] = boardFactory.createHiddenUnit(idHidden, go);
                  //console.log("created hidden unit:", idHidden, id, uis[idHidden]);
                } else {
                  //increment counter of hidden unit by 1
                  boardFactory.updateUnitCounter(go, uis[idHidden], 1);
                }
                break;
              case "action_card":
              case "investment_card":
                let ui = cardFactory.createCard(id, go, ttext);
                uis[id] = ui;
                if (isHandCard(go, currentFaction)) {
                  cardFactory.placeCard(ui, currentFaction);
                }
                break;
            }
          } else {
            //check property changes
            let ui = uis[id];

            for (prop in go) {
              //map values of property to ui
              switch (prop) {
                case "tile":
                  //make sure this is a cadre
                  if (go.obj_type != "unit") {
                    //console.log("trying to place a", go.obj_type);
                  }
                  let tile = go.tile;
                  let unitTile = ui.getTag("tile");
                  if (unitTile != tile) {
                    //console.log("PLACE! update tile from", unitTile, "to", tile);
                    //remove unit from old tile
                    boardFactory.removeUnitFrom(ui, tile);
                    boardFactory.placeUnit(ui, tile);
                  }
                  break;
                case "cv":
                  //make sure this is a cadre
                  if (go.obj_type != "unit") {
                    //console.log("trying to attach cv to ", go.obj_type);
                  }
                  let cv = go[prop];
                  let unitCV = ui.getTag("cv");
                  if (unitCV != cv) {
                    //console.log("update cv from", unitCV, "to", cv);
                    boardFactory.updateCv(ui, cv);
                  }
                  break;
                case "top":
                case "wildcard":
                case "year":
                case "espionage":
                  //console.log('updating card:',ui)
                  let title = ui.getTag("title");
                  if (title != go[prop]) {
                    //console.log(title,go,ui)
                    cardFactory.updateCardContent(ui.id, ui, go, ttext);
                  }
                  break;
              }
            }
          }

          switch (go.obj_type) {
            case "action_card":
            case "investment_card":
              if (go.visible.set.includes(currentFaction)) {
                cardFactory.placeCard(uis[id], currentFaction);
              }
              break;
            case "unit":
              let faction = go.visible.set[0]; //ms.getTag("faction");
              let tile = go.tile; //ms.getTag("tile");
              let idHidden = getHiddenId(faction, tile);
              //show unit if owner currentFaction, otherwise show hidden unit
              if (faction == currentFaction) {
                uis[id].show();
                uis[idHidden].hide();
              } else {
                uis[idHidden].show();
                if (id in uis) {
                  uis[id].hide();
                }
              }
              break;
          }
        }
      }

      function updateUI_vorOverride() {
        var currentFaction = G.faction;
        var currentView = G[currentFaction];

        for (id in currentView) {
          let go = currentView[id];
          let ttext = JSON.stringify(go);

          if (!(id in uis)) {
            //create object
            switch (go.obj_type) {
              case "tile":
                //console.log("create region", id);
                uis[id] = boardFactory.createTile(id, ttext);
                break;
              case "unit":
                console.log("create unit", id);
                let faction = currentFaction;

                if (isUnitOfFaction(go, currentFaction)) {
                  uis[id] = boardFactory.createUnit(id, currentFaction, go, ttext);
                  boardFactory.updateCv(uis[id], go.cv);
                } else {
                  faction = go.visible.set[0];
                }
                console.log("unit", uis[id], "id:::", id);
                //create or update hidden unit
                let idHidden = getHiddenId(faction, go.tile);
                if (!(idHidden in uis)) {
                  uis[idHidden] = boardFactory.createHiddenUnit(idHidden, go);
                  console.log("created hidden unit:", idHidden, id, uis[idHidden]);
                } else {
                  //increment counter of hidden unit by 1
                  boardFactory.updateUnitCounter(go, uis[idHidden], 1);
                }
                break;
              case "action_card":
              case "investment_card":
                let ui = cardFactory.createCard(id, go, ttext);
                uis[id] = ui;
                if (isHandCard(go, currentFaction)) {
                  cardFactory.placeCard(ui, currentFaction);
                }
                break;
            }
          } else {
            //check property changes
            let ui = uis[id];

            for (prop in go) {
              //map values of property to ui
              switch (prop) {
                case "tile":
                  //make sure this is a cadre
                  if (go.obj_type != "unit") {
                    console.log("trying to place a", go.obj_type);
                  }
                  let tile = go.tile;
                  let unitTile = ui.getTag("tile");
                  if (unitTile != tile) {
                    //console.log("PLACE! update tile from", unitTile, "to", tile);
                    //remove unit from old tile
                    boardFactory.removeUnitFrom(ui, tile);
                    boardFactory.placeUnit(ui, tile);
                  }
                  break;
                case "cv":
                  //make sure this is a cadre
                  if (go.obj_type != "unit") {
                    console.log("trying to attach cv to ", go.obj_type);
                  }
                  let cv = go[prop];
                  let unitCV = ui.getTag("cv");
                  if (unitCV != cv) {
                    //console.log("update cv from", unitCV, "to", cv);
                    boardFactory.updateCv(ui, cv);
                  }
                  break;
                case "top":
                case "wildcard":
                case "year":
                case "espionage":
                  //console.log('updating card:',ui)
                  let title = ui.getTag("title");
                  if (title != go[prop]) {
                    //console.log(title,go,ui)
                    cardFactory.updateCardContent(ui.id, ui, go, ttext);
                  }
                  break;
              }
            }
          }

          switch (go.obj_type) {
            case "action_card":
            case "investment_card":
              if (go.visible.set.includes(currentFaction)) {
                cardFactory.placeCard(uis[id], currentFaction);
              }
              break;
            case "unit":
              let faction = go.visible.set[0]; //ms.getTag("faction");
              let tile = go.tile; //ms.getTag("tile");
              let idHidden = getHiddenId(faction, tile);
              //show unit if owner currentFaction, otherwise show hidden unit
              if (faction == currentFaction) {
                uis[id].show();
                uis[idHidden].hide();
              } else {
                uis[idHidden].show();
                if (id in uis) {
                  uis[id].hide();
                }
              }
              break;
          }
        }
      }

      function updateUI_couldBreak() {
        var currentFaction = G.faction;
        var currentView = G[currentFaction];

        for (id in currentView) {
          let go = currentView[id];
          let ttext = JSON.stringify(go);

          if (!(id in uis)) {
            //create object
            switch (go.obj_type) {
              case "tile":
                //console.log("create region", id);
                uis[id] = boardFactory.createTile(id, ttext);
                break;
              case "unit":
                //console.log("create unit", id);
                let faction = currentFaction;
                if (isUnitOfFaction(go, currentFaction)) {
                  uis[id] = boardFactory.createUnit(id, currentFaction, go, ttext);
                  boardFactory.updateCv(uis[id], go.cv);
                } else {
                  faction = go.visible.set[0];
                }
                //create or update hidden unit
                let idHidden = getHiddenId(faction, go.tile);
                if (!(idHidden in uis)) {
                  uis[idHidden] = boardFactory.createHiddenUnit(idHidden, go);
                  console.log("created hidden unit:", idHidden, id, uis[idHidden]);
                } else {
                  //increment counter of hidden unit by 1
                  boardFactory.updateUnitCounter(go, uis[idHidden], 1);
                }
                break;
              case "action_card":
              case "investment_card":
                let ui = cardFactory.createCard(id, go, ttext);
                uis[id] = ui;
                if (isHandCard(go, currentFaction)) {
                  cardFactory.placeCard(ui, currentFaction);
                }
                break;
            }
          } else {
            //check property changes
            let ui = uis[id];

            for (prop in go) {
              //map values of property to ui
              switch (prop) {
                case "tile":
                  //make sure this is a cadre
                  if (go.obj_type != "unit") {
                    console.log("trying to place a", go.obj_type);
                  }
                  let tile = go.tile;
                  let unitTile = ui.getTag("tile");
                  if (unitTile != tile) {
                    //console.log("PLACE! update tile from", unitTile, "to", tile);
                    //remove unit from old tile
                    boardFactory.removeUnitFrom(ui, tile);
                    boardFactory.placeUnit(ui, tile);
                  }
                  break;
                case "cv":
                  //make sure this is a cadre
                  if (go.obj_type != "unit") {
                    console.log("trying to attach cv to ", go.obj_type);
                  }
                  let cv = go[prop];
                  let unitCV = ui.getTag("cv");
                  if (unitCV != cv) {
                    //console.log("update cv from", unitCV, "to", cv);
                    boardFactory.updateCv(ui, cv);
                  }
                  break;
                case "top":
                case "wildcard":
                case "year":
                case "espionage":
                  //console.log('updating card:',ui)
                  let title = ui.getTag("title");
                  if (title != go[prop]) {
                    //console.log(title,go,ui)
                    cardFactory.updateCardContent(ui.id, ui, go, ttext);
                  }
                  break;
              }
            }
          }

          //update visibility
          let ms = uis[id];

          switch (go.obj_type) {
            case "action_card":
            case "investment_card":
              if (go.visible.set.includes(currentFaction)) {
                cardFactory.placeCard(ms, currentFaction);
              }
              break;
            case "unit":
              let faction = ms.getTag("faction");
              let tile = ms.getTag("tile");
              let idHidden = getHiddenId(faction, tile);
              //show unit if owner currentFaction, otherwise show hidden unit
              if (faction == currentFaction) {
                uis[id].show();
                uis[idHidden].hide();
              } else {
                uis[idHidden].show();
                uis[id].hide();
              }
              break;
          }
        }
      }
    </script>
    <!-- #endregion FRONT END functions -->

    <!-- #region helper functions -->
    <script>
      function hideCommands() {
        G.commands.map(id => {
          if (id in uis) {
            uis[id].hide();
          }
        });
      }
      function addUI(id) {
        //add a simple selectable object to selectables area selDiv
        // <div id='selDiv' class="div" style="display:none"><svg id='selSvg' class='svg'><g id='selG'></g></svg></div>
        let ms = undefined;
        if (G["nationality"].includes(id)) {
          let d = document.getElementById("selDiv");
          let g = document.getElementById("selG");
          let sz = SZ.cadreDetail;
          ms = new MS(id, g)
            .roundedRect({w: sz, h: sz, fill: troopColors[id], rounding: sz * 0.1})
            .text({txt: id, fz: 12})
            .roundedRect({className: "overlay region hible selectable", w: sz, h: sz, rounding: sz * 0.1});
          ms.tag("type", "nationality");
          //console.log(id);
          uis[id] = ms;
          return ms;
        } else if (G["unit_type"].includes(id)) {
          let d = document.getElementById("selDiv");
          let g = document.getElementById("selG");
          let sz = SZ.cadreDetail;
          ms = new MS(id, g)
            .roundedRect({w: sz, h: sz, fill: "black", rounding: sz * 0.1})
            .image({w: sz, h: sz, path: "/_front/assets/images/" + id + ".svg", rounding: sz * 0.1})
            .roundedRect({className: "overlay region hible selectable", w: sz, h: sz, rounding: sz * 0.1});

          ms.tag("type", "unit_type");
          //console.log(id);
          uis[id] = ms;
          return ms;
        } else {
          //this is some kind of a command
          //console.log("addUI: adding button!!!!!!!!!!!!!!!!!!!*******", id);
          G.commands.push(id);
          let d = document.getElementById("buttonDiv");
          let b = new MS(id, d, false).button({txt: id, className: "msToggleButton"}).draw();
          //console.log(b);

          //let b = document.createElement('button');
          //b.id = id;
          //b.textContent = id;
          //d.appendChild(b);
          //b.addEventListener("click", onSelected);
          uis[id] = b;
          //console.log("button ms", b, d);
          return b;
        }
      }
      function getUI(id) {
        //console.log('id=',id)
        if (id in uis) {
          //console.log(id,' is in uis!',uis[id])
        }
        return id in uis ? uis[id] : addUI(id);
      }
      function isHandCard(go, faction) {
        let lst = go.visible.set;
        return lst.includes(faction);
      }
      function getHiddenId(faction, tile) {
        return faction + "_" + tile;
      }
      function highlightObjects(allTuples, choices, selection) {
        let allIds = [];
        allTuples.map(x => x.map(id => addIf(id, allIds)));
        //console.log("all ids:", allIds.toString());

        let allUIs = allIds.map(id => getUI(id));
        //console.log("all uis:", allUIs);

        let choiceIds = [];
        choices.map(x => x.map(id => addIf(id, choiceIds)));
        let choiceUIs = choiceIds.map(id => getUI(id));

        let selectedIds = selection;
        let selUIs = selectedIds.map(id => getUI(id));

        //console.log("allUIs", allUIs);
        //console.log("selectedIds", selectedIds);
        //console.log("choiceIds:", choiceIds.toString());

        for (const ui of allUIs) {
          if (selectedIds.includes(ui.id)) {
            ui.select();
          } else if (choiceIds.includes(ui.id)) {
            //console.log("highlight:", ui.id, typeof ui.id, ui);
            makeSelectable(ui, onSelected);
          } else {
            //console.log("not highlighted:", ui.id, typeof ui.id, ui);
            makeUnselectable(ui);
          }
        }
        show(bSkipAction);

        return {all: allUIs, choice: choiceUIs, selected: selUIs};
      }
      function isUnitOfFaction(go, faction) {
        return go.visible.set.includes(faction);
      }
      function lineupSelectables(choiceUIs) {
        let gap = 10;
        let x = 30;
        let y = 20;
        let sz = SZ.cadreDetail;
        let res = [];
        //console.log('lineupSelectables',choiceUIs)
        for (const ui of choiceUIs) {
          //console.log(ui.id)
          if (isNationality(ui)) {
            //console.log('is selectable:',ui.id)
            res.push(ui);
            y += gap;
            ui.show();
            ui.setPos(x, y).draw();
            y += gap + sz;
          }
        }
        for (const ui of choiceUIs) {
          //console.log(ui.id)
          if (isUnit(ui)) {
            //console.log('is selectable:',ui.id)
            res.push(ui);
            y += gap;
            ui.show();
            ui.setPos(x, y).draw();
            y += gap + sz;
          }
        }
        return res;
      }
      function makeSelectable(ui, handler) {
        if (ui.id in G.commands) {
          show(ui);
        } //for buttons
        else {
          ui.highlight();
          ui.isEnabled = true;
          //console.log(handler)
          ui.clickHandler = handler;
        }
      }
      function makeUnselectable(ui) {
        if (ui.id in G.commands) {
          hide(ui);
        } //for buttons
        else {
          // it is an ms
          ui.unselect();
          ui.unhighlight();
          ui.isEnabled = false;
          ui.clickHandler = null;
        }
      }
      function openSelectionIfPopulated(choiceUIs) {
        let d = document.getElementById("selDiv");
        //console.log(d.classList)
        if (!d.classList.contains("hidden")) return;
        //console.log("_________________________");
        //console.log("*** openSelectionIfPopulated ***", currentChoicesByType);
        let natOrUnits = lineupSelectables(choiceUIs);
        //console.log('OPENSELECTIONIFPOPULATED',natOrUnits)
        if (!empty(natOrUnits)) {
          let dMain = document.getElementById("mainDiv");
          dMain.classList.remove("grid-hidefirst");
          dMain.classList.add("grid-container");
          d.classList.remove("hidden");
        }
      }
      function closeSelection() {
        //console.log("closeSelection");
        hide(bSkipAction);

        let allUIs = [];
        choiceTuples.map(x => x.map(id => addIf(uis[id], allUIs)));

        selids = [];
        // selectedIds = {};
        // currentChoicesByType = {};
        choiceTuples = [];
        //console.log("allUIs", allUIs);
        allUIs.map(x => makeUnselectable(x));
        //choiceUIs = [];
      }
      function hideSelectionPanel() {
        //console.log("hideSelectionPanel", choiceTuples);
        closeSelection();
        let d = document.getElementById("selDiv");
        if (d.classList.contains("hidden")) return;
        let dMain = document.getElementById("mainDiv");
        let g = document.getElementById("selG");
        NodeList.prototype.forEach = Array.prototype.forEach;
        var children = g.childNodes;
        children.forEach(ch => getUI(ch.id).hide());
        d.classList.add("hidden");
        dMain.classList.add("grid-hidefirst");
        dMain.classList.remove("grid-container");
      }
      function isNationality(ui) {
        return G.nationality.includes(ui.id);
        //return ui.constructor.name == "MS" && ui.getTag('type')=='nationality';
      }
      function isUnit(ui) {
        return G["unit_type"].includes(ui.id);
      }
      function iCommand(ui) {
        return G["commands"].includes(ui.id);
      }
    </script>
    <!-- #endregion selection -->

    <!-- #region setup -->
    <script>
      var skipActions = 46; //skip to gov: 73; //skip to prod: 46; //0;
      var fileCounter = 0;

      var nextFaction;
      // var preparingForTurnChange = false;
      // var playerPressedPass = false;
      // var passTimer;

      var G = {Axis: {}, West: {}, USSR: {}, log: [], faction: "West"};
      var uis = {}; //by id

      var selids = [];
      var choiceTuples = []; // all tuples in a selection action
      //var choiceUIs = [];

      var backendServerUrl = "http://localhost:5000/"; //local server
      var msgCounter = 0;

      const board = document.getElementById("boardG");
      const cardDisplay = document.getElementById("cardDisplay");
      const cardsG = document.getElementById("cardsG");
      const bNextPlayer = document.getElementById("bNextPlayer");
      const bSkipAction = document.getElementById("bSkipAction");
      const bPass = document.getElementById("bPass");

      board.setAttribute("transform", `translate(0,0) scale(${MIN_SCALE})`);
      //board.setAttribute("transform", `translate(-400,-400) scale(${1})`);
      board.addEventListener("wheel", ev => {
        onwheel(ev, board);
      });
      board.addEventListener("pointerdown", ev => {
        onmousedown(ev);
      });
      addEventListener("mouseup", ev => {
        onmouseup(ev, board);
      });
      addEventListener("mousemove", ev => {
        onmousemove(ev, board);
      });
      addEventListener("dblclick", ev => reset(ev, board));

      var boardFactory = null;
      var cardFactory = null;

      const SZ = {
        //various sizes used
        region: 180,
        pAxis: {x: 0, y: 20}, // this is where on the region placement of cadre is started
        pWest: {x: -50, y: -30},
        pUSSR: {x: +50, y: -30},
        cadrePrototype: 60,
        sumCadre: 60,
        cadreDetail: 44,
        cardWidth: 100,
        cardHeight: 150
      };
    </script>
    <!-- #endregion setup -->

    <script>
      //*** execution starts here ***
      loadYML("/common/assets/config/map_pos.yml", data => {
        boardFactory = new BoardFactory(board, data, SZ);
        cardFactory = new CardFactory(cardDisplay, cardsG, SZ.cardWidth, SZ.cardHeight);
        let decks = boardFactory.createDecks();
        //console.log(decks);
        uis.action_card = decks.action_card;
        uis.investment_card = decks.investment_card;
        //console.log(uis);
        loadYML("/common/assets/config/unit_count.yml", data => {
          G["unitCount"] = data;
          G["nationality"] = Object.keys(data); //'Germany','Britain',...
          G["unit_type"] = Object.keys(data["Germany"]); //'Infantry','Tank'...
          G["commands"] = [];
          //console.log(G);
          loadYML("/common/assets/config/nations.yml", data => {
            G["nations"] = Object.keys(data);
            boardFactory.addMapPositions(data);
            send("init/hotseat/" + G.faction);
          });
        });
      });
    </script>
  </body>
</html>
