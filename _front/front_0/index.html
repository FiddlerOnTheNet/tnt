<!DOCTYPE html>
<html>
  <head>
    <title>a97</title>
    <link rel="shortcut icon" href="#" />
    <link rel="stylesheet" type="text/css" href="/common/css/commonStyles.css" />
    <link rel="stylesheet" type="text/css" href="/common/css/msStyles.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/3.12.2/js-yaml.js"></script>
    <script src="https://www.w3schools.com/lib/w3.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

    <script src="/common/js/helpers.js"></script>
    <script src="/common/js/panzoom.js"></script>
    <script src="/common/js/MS.js"></script>
    <script src="/common/js/BoardFactory.js"></script>
    <script src="/common/js/CardFactory.js"></script>
    <script src="/common/js/MTree.js"></script>
    <script src="/common/js/MParser.js"></script>
    <script src="/common/js/MScanner.js"></script>
  </head>
  <body>
    <!-- #region HTML -->
    <div id="mainDiv" class="grid-hidefirst">
      <div id="statusDiv" class="div">status</div>
      <div id="selDiv" class="div hidden">
        <svg id="selSvg" width="60" height="760"><g id="selG"></g></svg>
      </div>
      <div id="rootDiv" class="div" style="background-color:rgba(86, 182, 222);">
        <svg width="100%" height="100%" style="box-sizing:border-box;">
          <g id="boardG" viewBox="0 0 3400 2200">
            <image id="imgMap" width="3400" height="2200" href="/common/assets/TTmap.jpg" />
          </g>
        </svg>
      </div>
      <div id="logDiv" class="div">log display</div>
      <div id="buttonDiv" class="div">
        <button id="bNextPlayer" class="hidden" onclick="onClickNextPlayer()">next player</button>
        <button id="bSave" onclick="saveGameState()">save</button>
        <button id="bPass" class="hidden" onclick="onClickPass()">pass</button>
      </div>
      <div id="cardDisplay" class="div" style='height:200px'>
        <svg width="100%" height="100%" style="box-sizing:border-box;">
          <g id="cardsG"></g>
        </svg>
      </div>
      <div id="chatWindow" class="div">
        <button id='bSkipAction' onclick="skipAction()">skip</button>
      </div>
    </div>
    <!-- #endregion HTML -->

    <!-- #region functions -->
    <script>
      function send(url) {
        url = backendServerUrl + url;
        msgCounter += 1;
        console.log(msgCounter, "request sent: ", url);
        w3.http(url, function() {
          if (this.readyState == 4 && this.status == 200) {
            processData(this.responseText);
          }
        });
      }
      function skipAction() {
        let tuple = choiceTuples[0];
        let url = "action/" + G.faction + "/" + tuple.join("+");
        closeSelection();
        send(url);
      }
      function saveGameState() {
        //console.log(G);
        //console.log("_____________");
        //settings = {any_kind_of_object: true};
        json_str = JSON.stringify(G);
        saveFile("yourfilename.json", "data:application/json", new Blob([json_str], {type: ""}));
      }
      function onClickNextPlayer() {
        hide(bNextPlayer);
        cardFactory.clearCards();
        //TODO: hide board objects?

        G.faction = nextFaction;
        send("status/" + G.faction);
      }
      function onClickPass() { // macht eh dasselbe wie onClickNextPlayer
        hide(bNextPlayer);
        cardFactory.clearCards();
        //TODO: hide board objects?

        G.faction = nextFaction;
        send("status/" + G.faction);
      }
      function processData(str) {
        let data = JSON.parse(str);
        //console.log(data);
        if (data === undefined) {
          //console.log("!!!", str, "!!!");
        } else {
          let faction = G.faction;
          let g = G[faction];
          //console.log(data);
          //log
          if ("log" in data) {
            G.log.push(data.log);
          }
          //created
          for (id in data.created) {
            g[id] = data.created[id]; //overwride object of have already
          }
          //updated
          for (id in data.updated) {
            //not sure if have to do this really, since possibly no need
            // actually, the object might NOT exist,
            // therefore, just create it if it does not exist!!!

            if (!(id in g)) {
              console.log("NON EXISTING:", id);
              g[id] = data.updated[id];
            } else {
              let o = g[id]; //this object should exist since it is being updated!
              //each property of this object should be changed as in data.updated
              let orig = data.updated[id];
              for (prop in orig) {
                o[prop] = orig[prop];
              }
            }
          }
          //removed

          for (id in data.removed) {
            console.log(id, "is in removed!!!!!!!!!!!!!!");
            break;
            //not sure if should do anything!
            // if (id in g) {
            //   delete g[id];
            // }
          }

          //hier mach sowas wie Presenter.updateUI();
          updateUI();

          //either actions or waiting_for:
          console.log("*** actions starts ***");
          console.log(data.actions);


          json_str = JSON.stringify(data.actions);
          //saveFile("_a"+fileCounter+".json", "data:application/json", new Blob([json_str], {type: ""}));
          fileCounter+=1;

          if ("actions" in data) {
            //console.log("there are actions!!!! tree:");
            let sActions = JSON.stringify(data.actions);
            console.log('vor make server tree')
            let serverTree = new MParser(sActions).tree;
            console.log('nach make server tree')
            serverTree.print();
            choiceTuples = getChoices(serverTree);
            //console.log(choiceTuples);

            if (skipActions > 0) {
              skipActions -= 1;
              let url = "action/" + G.faction + "/" + choiceTuples[0].join("+");
              send(url);
            } else {
              currentChoiceTuples = choiceTuples.slice();
              //console.log("choices", choiceTuples);
              currentChoicesByType = computeChoicesByType(currentChoiceTuples);

              allSelectionUIs = getObjects(currentChoicesByType);
              //console.log("_____________selection:");
              //console.log(allSelectionUIs.map(x => x.id));
              openSelectionIfPopulated();
              show(bSkipAction);
            }
          } else {
            console.log(data.waiting_for, "*** will change turn!!! ***");
            console.log(data);
            show(bNextPlayer);
            hideSelectionPanel();
            nextFaction = data.waiting_for.set[0];
          }
        }
      }
      var fileCounter=0;
      function onSelected(ev) {
        let id = evToId(ev);
        let type = getType(id);
        //console.log(id, " selected!");

        if (selectedIds[type] == id) {
          //unselect this object and remove selectedIds[type]
          delete selectedIds[type];
        } else selectedIds[type] = id;

        //get all types in currentChoicesByType
        let typesNeeded = Object.keys(currentChoicesByType);
        //console.log("types needed:", typesNeeded);

        let matchingTuples = [];
        for (const tuple of choiceTuples) {
          let couldbe = true;
          for (const type in selectedIds) {
            if (!tuple.includes(selectedIds[type])) {
              couldbe = false;
              break;
            }
          }
          if (couldbe) matchingTuples.push(tuple);
        }
        currentChoicesByType = computeChoicesByType(matchingTuples);

        let objectList = getObjects(currentChoicesByType);
        //console.log("new choices:", objectList.map(x => x.id));

        for (const type in currentChoicesByType) {
          if (currentChoicesByType[type].length == 1) {
            selectedIds[type] = currentChoicesByType[type][0];
            let ms = getMS(selectedIds[type]);
            ms.select();
          }
        }

        //if have one of each type in selectedIds, choice is complete: send it
        let selectedValues = Object.values(selectedIds);
        //console.log("selected Values:", selectedValues);
        //console.log("selectedIds:", selectedIds);

        if (typesNeeded.length == selectedValues.length) {
          //unselect and unhighlight all choice!
          // for (const ms of allSelectionUIs) {
          //   makeUnselectable(ms);
          // }
          let tuple = findTuple(selectedValues, choiceTuples);
          closeSelection();
          //console.log(tuple, selectedValues, choiceTuples);
          if (!tuple) {
            //console.log("non existing tuple");
          } else {
            let url = "action/" + G.faction + "/" + tuple.join("+");
            send(url);
          }
        } else {
          console.log("*** updating selections ***");
          for (const id of selectedValues) {
            getMS(id).select();
            //console.log("select", id, getMS(id));
          }
          for (const ms of allSelectionUIs) {
            if (selectedValues.includes(ms.id)) continue;
            //console.log('remove',ms.id)
            makeUnselectable(ms);
          }
          for (const ms of objectList) {
            if (selectedValues.includes(ms.id)) continue;
            makeSelectable(ms, onSelected);
            //console.log('highlight:',ms.id,ms)
          }
          show(bSkipAction);
        }
      }
    </script>
    <!-- #endregion functions -->

    <!-- #region FRONT END functions -->
    <script>
      function isHandCard(go, faction) {
        let lst = go.visible.set;
        return lst.includes(faction);
      }
      function updateUI() {
        //have to know how to create an object of type: obj_type
        //example: create a tile object
        //console.log("*** starting to process ***");
        var currentFaction = G.faction;
        var currentView = G[currentFaction];
        for (id in currentView) {
          let go = currentView[id];
          let ttext = JSON.stringify(go);
          //console.log(go.obj_type);
          if (!(id in uis)) {
            // THIS OBJECT NEEDS TO BE CREATED!
            //console.log("create:", id);
            //create object with immutable properties (mutable properties in update)
            switch (go.obj_type) {
              case "tile":
                //console.log("create region", id);
                uis[id] = boardFactory.createTile(id, ttext);
                //muss noch die units placen! irgendwie irgendwann!
                break;
              case "unit":
                //console.log("create unit", id);
                uis[id] = boardFactory.createUnit(id, go.nationality, go.type, ttext);
                break;
              case "action_card":
                let ui = cardFactory.createCard(id, go, ttext);
                uis[id] = ui;
                if (isHandCard(go, currentFaction)) {
                  cardFactory.placeCard(ui, currentFaction);
                }
                break;
              case "investment_card":
                uis[id] = cardFactory.createCard(id, go, ttext);
                break;
            }
          }
        }
        for (id in currentView) {
          let go = currentView[id];
          let ttext = JSON.stringify(go);
          //console.log('updateUI: update properties')

          //update properties
          if (!(id in uis)) {
            console.log("ERROR!!!!!", id, "DOES NOT EXIST!!!!!");
            return;
          }
          let ui = uis[id];

          for (prop in go) {
            //map values of property to ui
            switch (prop) {
              case "tile":
                //make sure this is a cadre
                if (go.obj_type != "unit") {
                  //console.log("trying to place a", go.obj_type);
                }
                let tile = go.tile;
                let unitTile = ui.getTag("tile");
                if (unitTile != tile) {
                  //console.log("update tile from", unitTile, "to", tile);
                  let uiTile = uis[tile];
                  boardFactory.placeUnit(ui, tile, uiTile, currentFaction);
                }
                break;
              case "cv":
                //make sure this is a cadre
                if (go.obj_type != "unit") {
                  //console.log("trying to attach cv to ", go.obj_type);
                }
                let cv = go[prop];
                let unitCV = ui.getTag("cv");
                if (unitCV != cv) {
                  //console.log("update cv from", unitCV, "to", cv);
                  boardFactory.updateCv(ui, cv);
                }
                break;
              case "top":
              case "wildcard":
                //console.log('updating card:',ui)
                let title = ui.getTag("title");
                if (title != go[prop]) {
                  cardFactory.updateCardContent(ui.id, ui, go, ttext);
                  if (isHandCard(go, currentFaction)) {
                    cardFactory.placeCard(ui, currentFaction);
                  }
                }
                break;
            }
          }
          //update visibility
        }
      }

      function updateUI_old() {
        //have to know how to create an object of type: obj_type
        //example: create a tile object
        //console.log("*** starting to process ***");
        var currentFaction = G.faction;
        var currentView = G[currentFaction];
        for (id in currentView) {
          let go = currentView[id];
          let ttext = JSON.stringify(go);
          //console.log(go.obj_type);
          if (!(id in uis)) {
            // THIS OBJECT NEEDS TO BE CREATED!
            //console.log("create:", id);
            //create object with immutable properties (mutable properties in update)
            switch (go.obj_type) {
              case "tile":
                //console.log("create region", id);
                uis[id] = boardFactory.createTile(id, ttext);
                //muss noch die units placen! irgendwie irgendwann!
                break;
              case "unit":
                //console.log("create unit", id);
                uis[id] = boardFactory.createUnit(id, go.nationality, go.type, ttext);
                break;
              case "action_card":
                uis[id] = cardFactory.createCard(id, go, ttext);
                break;
              case "investment_card":
                uis[id] = cardFactory.createCard(id, go, ttext);
                break;
            }
          }
        }
        for (id in currentView) {
          let go = currentView[id];
          let ttext = JSON.stringify(go);
          //console.log('updateUI: update properties')

          //update properties
          if (!(id in uis)) {
            console.log("ERROR!!!!!", id, "DOES NOT EXIST!!!!!");
            return;
          }
          let ui = uis[id];

          // if (go.obj_type == "action_card") {
          //   //just place the card to next spot
          //   // if it is a card, properties do not change
          //   // just display cards in currenview if have not been displayed yet
          // } else {
          for (prop in go) {
            //map values of property to ui
            switch (prop) {
              case "tile":
                //make sure this is a cadre
                if (go.obj_type != "unit") {
                  //console.log("trying to place a", go.obj_type);
                }
                let tile = go.tile;
                let unitTile = ui.getTag("tile");
                if (unitTile != tile) {
                  //console.log("update tile from", unitTile, "to", tile);
                  let uiTile = uis[tile];
                  boardFactory.placeUnit(ui, tile, uiTile, currentFaction);
                }
                break;
              case "cv":
                //make sure this is a cadre
                if (go.obj_type != "unit") {
                  //console.log("trying to attach cv to ", go.obj_type);
                }
                let cv = go[prop];
                let unitCV = ui.getTag("cv");
                if (unitCV != cv) {
                  //console.log("update cv from", unitCV, "to", cv);
                  boardFactory.updateCv(ui, cv);
                }
                break;
              case "top":
              case "wildcard":
                //console.log('updating card:',ui)
                let title = ui.getTag("title");
                if (title != go[prop]) {
                  cardFactory.updateCardContent(ui.id, ui, go, ttext);
                  cardFactory.placeCard(ui);
                }
                break;
            }
          }
          // }
          //update visibility
        }

        //test area
        //darkerColor(255,255,0);
        //each object after creation has a
      }
    </script>
    <!-- #endregion FRONT END functions -->

    <!-- #region selection super messy code: TODO CLEANUP!!!! -->
    <script>
      //selection functions
      function computeChoicesByType(tuples) {
        let chByType = {};
        //hier erstmal unique ids >> currentChoicesByType

        for (const choice of tuples) {
          for (const id of choice) {
            if (id in uis) {
              let ms = uis[id];
              let type = ms.getTag("type");
              if (!(type in chByType)) {
                chByType[type] = [];
              }
              let lst = chByType[type];
              if (!lst.includes(id)) {
                lst.push(id);
                makeSelectable(ms, onSelected);
              }
            } else {
              //console.log(id);
              let ms = id in selectables ? selectables[id] : addSelectable(id);
              let type = ms.getTag("type");
              if (!(type in chByType)) {
                chByType[type] = [];
              }
              let lst = chByType[type];
              if (!lst.includes(id)) {
                lst.push(id);
                makeSelectable(ms, onSelected);
              }
            }
          }
        }
        return chByType;
      }
      function getType(id) {
        //den type von einer id sollte ich sehr viel einfacher finden!!!
        let ms = id in selectables ? selectables[id] : id in uis ? uis[id] : null; //consolidate?
        if (ms) return ms.getTag("type");
        else return "unknown";
      }
      function getMS(id) {
        let ms = id in selectables ? selectables[id] : id in uis ? uis[id] : null; //consolidate?
        return ms;
      }
      function getObjects(choicesByType) {
        return Object.values(choicesByType)
          .map(ids => ids.map(id => getMS(id)))
          .flat();
      }
      function findTuple(ids, tuples) {
        //console.log("findTuples", ids);
        for (const tuple of tuples) {
          let cand = true;
          for (const id of ids) {
            if (!tuple.includes(id)) {
              cand = false;
              break;
            }
          }
          if (cand) return tuple;
        }
        return null;
      }
      function makeSelectable(ms, handler) {
        ms.highlight();
        ms.isEnabled = true;
        //console.log(handler)
        ms.clickHandler = handler;
      }
      function makeUnselectable(ms) {
        ms.unselect();
        ms.unhighlight();
        ms.isEnabled = false;
        ms.clickHandler = null;
      }
      function openSelectionIfPopulated() {
        let d = document.getElementById("selDiv");
        //console.log(d.classList)
        if (!d.classList.contains("hidden")) return;
        //console.log("_________________________");
        //console.log("*** openSelectionIfPopulated ***", currentChoicesByType);
        lineupSelectables();
        for (const key in currentChoicesByType) {
          for (const id of currentChoicesByType[key]) {
            if (id in selectables) {
              let dMain = document.getElementById("mainDiv");
              dMain.classList.remove("grid-hidefirst");
              dMain.classList.add("grid-container");
              d.classList.remove("hidden");
              //console.log(id);
              return;
            }
          }
        }
      }
      function closeSelection() {
        hide(bSkipAction);
        selectedIds = {};
        currentChoicesByType = {};
        choiceTuples = [];
        allSelectionUIs.map(x => makeUnselectable(x));
        allSelectionUIs = [];
      }
      function hideSelectionPanel() {
        closeSelection();
        let d = document.getElementById("selDiv");
        if (d.classList.contains("hidden")) return;
        let dMain = document.getElementById("mainDiv");
        let g = document.getElementById("selG");
        NodeList.prototype.forEach = Array.prototype.forEach;
        var children = g.childNodes;
        children.forEach(ch => getMS(ch.id).hide());
        d.classList.add("hidden");
        dMain.classList.add("grid-hidefirst");
        dMain.classList.remove("grid-container");
      }
      function addSelectable(id) {
        //add a simple selectable object to selectables area selDiv
        // <div id='selDiv' class="div" style="display:none"><svg id='selSvg' class='svg'><g id='selG'></g></svg></div>
        let d = document.getElementById("selDiv");
        let g = document.getElementById("selG");
        let sz = SZ.cadreDetail;
        let ms = undefined;
        if (G["nationality"].includes(id)) {
          ms = new MS(id, g)
            .roundedRect({w: sz, h: sz, fill: troopColors[id], rounding: sz * 0.1})
            .text({txt: id, fz: 12})
            .roundedRect({className: "overlay region hible selectable", w: sz, h: sz, rounding: sz * 0.1});
          ms.tag("type", "nationality");
          //console.log(id);
          selectables[id] = ms;
        } else if (G["unit_type"].includes(id)) {
          ms = new MS(id, g)
            .roundedRect({w: sz, h: sz, fill: "black", rounding: sz * 0.1})
            .image({w: sz, h: sz, path: "/_front/assets/images/" + id + ".svg", rounding: sz * 0.1})
            .roundedRect({className: "overlay region hible selectable", w: sz, h: sz, rounding: sz * 0.1});

          ms.tag("type", "unit_type");
          //console.log(id);
          selectables[id] = ms;
        }
        return ms;
        //object type will get from G[]
      }
      function lineupSelectables() {
        let gap = 10;
        let x = 30;
        let y = 20;
        let sz = SZ.cadreDetail;
        for (const key in currentChoicesByType) {
          let id = currentChoicesByType[key][0];
          if (id in selectables) {
            y += gap;
            let ids = currentChoicesByType[key];
            let type = key;
            //console.log(type, ids);
            for (const id of ids) {
              if (!(id in selectables)) {
                //console.log(id, " not in selectables!");
                return;
              }
              let ms = selectables[id];
              ms.show();
              ms.setPos(x, y).draw();
              y += gap + sz;
            }
          }
        }
      }
      function getChoices(tree) {
        let branchlist = tree.branchlist();
        // branchlist = branchlist.map(l => l.slice(0, branchlen));
        branchlist = branchlist.map(b => cartesianOf(b)).flat();
        branchlist = branchlist.map(s => s.split("_"));
        //console.log(branchlist[0].toString());
        return branchlist;
      }
    </script>
    <!-- #endregion selection -->

    <!-- #region setup -->
    <script>
      var skipActions = 44;

      var nextFaction;
      // var preparingForTurnChange = false;
      // var playerPressedPass = false;
      // var passTimer;

      var G = {Axis: {}, West: {}, USSR: {}, log: [], faction: "West"};
      var uis = {}; //by id
      var selectables = {}; // by id, parts like "Germany" or "Infantry"

      var choiceTuples = []; // all tuples in a selection action
      var allSelectionUIs = [];
      var currentChoiceTuples = [];
      var currentChoicesByType = {};
      var selectedIds = {}; // one per type by type, depending on tuples to select, one list for each tuple component

      var backendServerUrl = "http://localhost:7777/"; //local server
      var msgCounter = 0;

      const board = document.getElementById("boardG");
      const cardDisplay = document.getElementById("cardDisplay");
      const cardsG = document.getElementById("cardsG");
      const bNextPlayer = document.getElementById("bNextPlayer");
      const bSkipAction = document.getElementById("bSkipAction");
      const bPass = document.getElementById("bPass");

      board.setAttribute("transform", `translate(0,0) scale(${MIN_SCALE})`);
      //board.setAttribute("transform", `translate(-400,-400) scale(${1})`);
      board.addEventListener("wheel", ev => {
        onwheel(ev, board);
      });
      board.addEventListener("pointerdown", ev => {
        onmousedown(ev);
      });
      addEventListener("mouseup", ev => {
        onmouseup(ev, board);
      });
      addEventListener("mousemove", ev => {
        onmousemove(ev, board);
      });
      addEventListener("dblclick", ev => reset(ev, board));

      var boardFactory = null;
      var cardFactory = null;

      const SZ = {
        //various sizes used
        region: 180,
        pAxis: {x: 0, y: 20}, // this is where on the region placement of cadre is started
        pWest: {x: -50, y: -30},
        pUSSR: {x: +50, y: -30},
        cadrePrototype: 60,
        sumCadre: 60,
        cadreDetail: 44,
        cardWidth: 100,
        cardHeight: 150
      };
    </script>
    <!-- #endregion setup -->

    <script>
      //*** execution starts here ***
      loadYML("/common/assets/config/map_pos.yml", data => {
        boardFactory = new BoardFactory(board, data, SZ);
        cardFactory = new CardFactory(cardDisplay, cardsG, SZ.cardWidth, SZ.cardHeight);
        boardFactory.createDecks();
        loadYML("/common/assets/config/unit_count.yml", data => {
          G["unitCount"] = data;
          G["nationality"] = Object.keys(data); //'Germany','Britain',...
          G["unit_type"] = Object.keys(data["Germany"]); //'Infantry','Tank'...
          send("init/hotseat/" + G.faction);
        });
      });
    </script>
  </body>
</html>
